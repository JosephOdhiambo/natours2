{
    "password": "pass1234",
    "name": "Jose Odhiambo"
} 
--------------------------------------------------
 //2) Update user document
  const user = await User.findById(req.user.id);
  user.name = 'Jonas';
  await user.save();
We cannot use save, but findByIdAndUpdate(). We couldn't use it before as we were handling sensitive data (passwords)
We are dealing with non sensitive data
--------------------------------------------------
{
    "name": "Jose Odhiambo"
}


--------------------------------------------------
we don't want to update everything that's on the body. Let's say user puts the role body.role = 'admin', 
user can also change the reset token.

  const updateUser = await User.findById(req.user.id, x, {
    new: true,
    runValidators: true
  });

x should only contain name and email. which are the only fields that
we want to allow to update. If the user tries to change the role, that will be filtered out so
that it never finds it way to the db.
const filteredBody = filterObj(req.body, 'name', 'email');
  const updateUser = await User.findById(req.user.id, filteredBody, {
    new: true,
    runValidators: true
  });


const filterObj = (obj, ...allowedFields) => {
  const newObj = {};
  Object.keys(obj).forEach(el => {
    if (allowedFields.includes(el)) newObj[el] = obj[el];
  });
  return newObj;
};

exports.updateMe = catchAsync(async (req, res, next) => {
  // 1) Create error if users POSTs password data
  if (req.body.password || req.body.passwordConfirm) {
    return next(
      new AppError(
        'This route is not for password updates. Please use /updateMyPassword',
        400
      )
    );
  }
  //2) Filtered out unwanted field names that are not allowed to be updated
  const filteredBody = filterObj(req.body, 'name', 'email');
  //3) Update user document
  const updateUser = await User.findById(req.user.id, filteredBody, {
    new: true,
    runValidators: true
  });
  res.status(200).json({
    status: 'success',
    data: {
      user: updateUser
    }
  });
});

Now the code will work. Let's update the name and role(which is not allowed)
PATCH - {{URL}}api/v1/users/updateMe

{
    "name": "Jose Odhiambo",
    "role": "admin"
}






____________________________________
In this section, we've added code to:
userController.js
const AppError = require('./../utils/appError');
!
!
!
const filterObj = (obj, ...allowedFields) => {
  const newObj = {};
  Object.keys(obj).forEach(el => {
    if (allowedFields.includes(el)) newObj[el] = obj[el];
  });
  return newObj;
};
!
!
!
exports.updateMe = catchAsync(async (req, res, next) => {
  // 1) Create error if user POSTs password data
  if (req.body.password || req.body.passwordConfirm) {
    return next(
      new AppError(
        'This route is not for password updates. Please use /updateMyPassword.',
        400
      )
    );
  }

  // 2) Filtered out unwanted fields names that are not allowed to be updated
  const filteredBody = filterObj(req.body, 'name', 'email');

  // 3) Update user document
  const updatedUser = await User.findByIdAndUpdate(req.user.id, filteredBody, {
    new: true,
    runValidators: true
  });

  res.status(200).json({
    status: 'success',
    data: {
      user: updatedUser
    }
  });
});

userRoutes.js
router.patch('/updateMe', authController.protect, userController.updateMe);

This is a nwe route we created that is a patch request