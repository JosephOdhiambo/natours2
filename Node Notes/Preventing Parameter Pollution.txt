Let's head out to postman and see why we need to prevent parameter pollution

First off, we need to login to use the getAllTours route

{{URL}}api/v1/users/login: POST
{
    "email": "admin@jonas.com",
    "password": "pass1234"
}

go to getAllTours route and ad some parameters
{{URL}}api/v1/tours?sort=duration&sort=price

The error is:
"message": "this.queryString.sort.split is not a function"

within apiFeatures.js:
 sort() {
    if (this.queryString.sort) {
      console.log(this.queryString.sort);
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      this.query = this.query.sort('-createdAt');
    }

    return this;
  }
[ 'duration', 'price' ]// result of 'console.log(this.queryString.sort)'

we'll use a middleware which will remove these duplicate fields

npm i hpp

http parameter pollution

run this request
{{URL}}api/v1/tours?sort=duration&sort=price

in app.js, add
app.use(hpp());



run the request again. 
It will succesfully give back all the tours and they will be sorted.

However, we want somw duplicate properties. e.g we might want to search for 
tours with a duration of 9 and 5.

{{URL}}api/v1/tours?duration=9&duration=5: GET


if we did not have our hpp middleware active, it would work.
We can whitelist some parameters.
Whitelist is simply an arrayof properties for which we actually allow duplicates in
the query string.


{{URL}}api/v1/tours?duration=9&duration=5: GET

we get 3 results instead of 8. The sanitization is succesful.
Plus our sort functionality still works

{{URL}}api/v1/tours?sort=duration&sort=price: GET
if we try running this request, it will sort the records appropriately so that hpp middleware is
working correctly.
We should specify other fields in our whitelist. eg if we want to search for ratingsAverage or ratingsQuantity


app.use(
  hpp({
    whitelist: [
      'duration',
      'ratingsAverage',
      'ratingsQuantity',
      'maxGroupSize',
      'difficulty',
      'price'
    ]
  })
);
We'll have to add other fields to this whitelist in future



app.js

const express = require('express');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');

const AppError = require('./utils/appError');
const globalErrorHandler = require('./controllers/errorController');
const tourRouter = require('./routes/tourRoutes');
const userRouter = require('./routes/userRoutes');

const app = express();
//1. GLOBAL MIDDLEWARES
//Security HTTP headers
app.use(helmet());

//Development logging
if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

//Limit requests from same API
const limiter = rateLimit({
  max: 100,
  windowMs: 60 * 60 * 1000,
  message: 'Too many requests from this IP, please try again in an hour'
});
app.use('/api', limiter);

//Body parser, reading data from the body into req.body
app.use(express.json({ limit: '10kb' }));

//Data sanitiation against nosql query injection
app.use(mongoSanitize());

//Data sanitiation against crosside scripting
app.use(xss());

//Prevent Parameter Pollution
app.use(
  hpp({
    whitelist: [
      'duration',
      'ratingsAverage',
      'ratingsQuantity',
      'maxGroupSize',
      'difficulty',
      'price'
    ]
  })
);

//Serving static files
app.use(express.static(`${__dirname}/public`));

//Test middleware
app.use((req, res, next) => {
  req.requestTime = new Date().toISOString();
  next();
});

//2. ROUTE HANDLERS

//3. ROUTES

//Mounting The router
app.use('/api/v1/tours', tourRouter);
app.use('/api/v1/users', userRouter);

app.all('*', (req, res, next) => {
  // const err = new Error(`Can't find ${req.originalUrl} on this server!`); //Built in error constuctor
  next(new AppError(`Can't find ${req.originalUrl} on this server!`, 404));
});

app.use(globalErrorHandler);
//4. START SERVER
module.exports = app;
